% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mtg_apply.R
\name{mtg_apply}
\alias{mtg_apply}
\title{Apply function to tree}
\usage{
mtg_apply(
  data,
  fun,
  scale,
  traversal = c("pre-order", "post-order", "in-order", "level", "ancestor")
)
}
\arguments{
\item{data}{The input MTG, as from \code{\link[=read_MTG]{read_MTG()}}}

\item{fun}{The function to apply (see details)}

\item{scale}{The scale to apply the function to.}

\item{traversal}{The traversal order of the tree. Can be any of 'pre-order',
'post-order', 'in-order', 'level', 'ancestor', or a custom function (see details)}
}
\value{
Nothing. The MTG is modified in place.
}
\description{
Apply function to tree
}
\details{
The traversal is as in \code{\link[data.tree:Traverse]{data.tree::Traverse()}}. Here's its documentation:

The traversal order is as follows. (Note that these descriptions are not precise and complete. They are meant for quick reference only. See the data.tree vignette for a more detailed description).
\itemize{
\item pre-order: Go to first child, then to its first child, etc.
\item post-order: Go to the first branch's leaf, then to its siblings, and work your way back to the root
\item in-order:Go to the first branch's leaf, then to its parent, and only then to the leaf's sibling
\item level: Collect root, then level 2, then level 3, etc.
\item ancestor: Take a node, then the node's parent, then that node's parent in turn, etc. This ignores the pruneFun
\item function: You can also provide a function, whose sole parameter is a Node object. The function is expected to return the node's next node, a list of the node's next nodes, or NULL.
}
}
\note{
The filter on scale is supposed to happen in \code{fun}. This approach gives the user more freedom.
}
\examples{
filepath= system.file("extdata", "simple_plant.mtg", package = "XploRer")
MTG = read_MTG(filepath)

# Defining the function to apply, here we compute the cross-section surface:

Width
fun = function(node) {
node$section_surface_parent = get_parent_value("Length","Width",  node = node)
}

# Applying the function to the MTG:
  mtg_apply(MTG = MTG, fun = fun)

# Checking it worked:
  mtg_df = ToDataFrameTree(mtg$MTG,"length","diameter","topological_order","section_surface","section_surface_childs","section_surface_parent")
}
